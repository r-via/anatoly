# Anatoly v0.2.0 — SPÉCIFICATION TECHNIQUE & PLAN D'IMPLÉMENTATION

**Version :** 0.2.0
**Date :** 24 février 2026
**Auteur :** Rémi Viau
**Objectif :** Ajouter un système RAG sémantique cross-file léger et intégré pour permettre à l'agent Claude de détecter automatiquement les similarités de fonctions à travers tout le codebase.

---

## 1. Objectif technique

- Créer un **lexique de Function Cards** pendant la review (via le Claude Agent SDK, dans la même session que l'audit).
- Générer des **embeddings locaux** pour chaque fonction (`all-MiniLM-L6-v2`, 384 dimensions).
- Stocker/indexer dans un **vector store embedded** (LanceDB).
- Exposer un **tool** `findSimilarFunctions` à l'agent Claude.
- Quand le RAG est activé, **remplacer** la détection de duplication manuelle (grep) par les résultats RAG dans le prompt de review.
- Garder le système **incrémental**, résilient, zéro-dépendance-réseau et dans l'esprit minimaliste d'Anatoly.

Aucune rupture de compatibilité avec v0.1.x.

---

## 2. Architecture ajoutée

Nouveau dossier : `src/rag/`

```
src/rag/
├── function-card.ts          # Schéma Zod + types
├── embeddings.ts             # Wrapper Xenova/all-MiniLM-L6-v2
├── vector-store.ts           # Wrapper LanceDB (init, upsert, search)
├── indexer.ts                # Logique d'indexation incrémentale
├── tools.ts                  # Tool definition pour @anthropic-ai/claude-agent-sdk
└── types.ts                  # Types partagés
```

Mise à jour de :
- `src/commands/run.ts` (flags CLI + orchestration)
- `src/utils/prompt-builder.ts` (injection des similarités + génération des cards)
- `src/core/reviewer.ts` (production des FunctionCards pendant la review)
- `src/core/review-writer.ts` (nouvelles sections dans .rev.md)
- `src/core/reporter.ts` (section duplications sémantiques dans report.md)
- `src/schemas/review.ts` (extension du schéma pour les cards)

---

## 3. FunctionCard — Schéma Zod

```ts
// src/rag/function-card.ts
import { z } from 'zod';

export const FunctionCardSchema = z.object({
  id: z.string(),                    // sha256(`${filePath}:${start}-${end}`)
  filePath: z.string(),
  name: z.string(),
  signature: z.string(),
  summary: z.string().max(400),      // résumé conceptuel (généré pendant la review)
  keyConcepts: z.array(z.string()),
  behavioralProfile: z.enum(['pure', 'sideEffectful', 'async', 'memoized', 'stateful', 'utility']),
  complexityScore: z.number().int().min(1).max(5),  // dérivé via heuristique cyclomatique (AST)
  calledInternals: z.array(z.string()),              // extrait statiquement via AST (tree-sitter)
  lastIndexed: z.string().datetime(),
});

export type FunctionCard = z.infer<typeof FunctionCardSchema>;
```

### Notes sur les champs dérivables sans LLM

- **`complexityScore`** : calculé localement via une heuristique cyclomatique (nombre de branches if/else/switch/ternaires dans l'AST tree-sitter).
- **`calledInternals`** : extrait statiquement via tree-sitter en parcourant les `call_expression` dans le corps de la fonction.
- **`summary`, `keyConcepts`, `behavioralProfile`** : générés par l'agent Claude pendant la session de review (zéro session supplémentaire).

---

## 4. Embeddings — Xenova/all-MiniLM-L6-v2

**Fichier :** `src/rag/embeddings.ts`

```ts
import { pipeline } from '@xenova/transformers';

let embedder: any = null;

export async function createEmbedder() {
  if (!embedder) {
    embedder = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
  }
  return embedder;
}

export async function embed(text: string): Promise<number[]> {
  const model = await createEmbedder();
  const output = await model(text, { pooling: 'mean', normalize: true });
  return Array.from(output.data);
}

export const EMBEDDING_DIM = 384;
```

- **Modèle :** `all-MiniLM-L6-v2` (~23 MB quantisé ONNX)
- **Dimensions :** 384
- **Téléchargement :** au `postinstall` via script dédié (pas de surprise au runtime)
- **Singleton :** le modèle est chargé une seule fois en mémoire par session

### Texte à embedder par fonction

```
${name} ${signature}
${summary}
${keyConcepts.join(' ')}
```

Concis pour maximiser le signal sur 384 dimensions.

### Installation du modèle

**Script :** `scripts/download-model.js`

```js
// Pré-télécharge le modèle ONNX au postinstall
const { pipeline } = require('@xenova/transformers');
pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2')
  .then(() => console.log('✓ Modèle all-MiniLM-L6-v2 téléchargé'))
  .catch((e) => console.warn('⚠ Téléchargement du modèle échoué, sera retéléchargé au premier usage:', e.message));
```

**package.json :**
```json
"scripts": {
  "postinstall": "node scripts/download-model.js"
}
```

---

## 5. Vector Store — LanceDB

**Fichier :** `src/rag/vector-store.ts`

- Initialisation : `.anatoly/rag/lancedb/` (créé automatiquement).
- Table : `function_cards`
- Colonnes : id (PK), filePath, name, summary, keyConcepts (JSON), embedding (vector 384), metadata (JSON du reste de la carte).
- Méthodes à implémenter :
  - `init()`
  - `upsert(cards: FunctionCard[], embeddings: number[][])` (incrémental via id)
  - `search(queryEmbedding: number[], limit: number, minScore: number)` → retourne cartes + score
  - `deleteByFile(filePath: string)` → nettoyage quand un fichier est supprimé

---

## 6. Génération des FunctionCards — Pendant la review

**Décision architecturale :** les FunctionCards sont produites par l'agent Claude **dans la même session** que la review de chaque fichier. L'agent a déjà lu le fichier et analysé les symboles — lui demander de remplir les cards en plus ne coûte quasiment rien.

### Modification du prompt système (`src/utils/prompt-builder.ts`)

Quand `--enable-rag` est actif, ajouter au prompt :

```
Pour chaque fonction/méthode du fichier, produis également une FunctionCard :
- summary : résumé conceptuel en 1-2 phrases (max 400 caractères)
- keyConcepts : 3-6 mots-clés décrivant le comportement
- behavioralProfile : pure | sideEffectful | async | memoized | stateful | utility
```

### Modification du schéma de sortie (`src/schemas/review.ts`)

Ajouter un champ optionnel à `ReviewFile` :

```ts
functionCards: z.array(FunctionCardOutputSchema).optional()
```

Où `FunctionCardOutputSchema` contient les champs générés par l'agent (summary, keyConcepts, behavioralProfile). Les champs dérivables (id, complexityScore, calledInternals, signature) sont calculés côté code après réception.

---

## 7. Indexation (incrémentale)

**Fichier :** `src/rag/indexer.ts`

- Appelée après la review, pour chaque fichier reviewé :
  1. Récupérer les FunctionCards depuis la review.
  2. Enrichir avec les champs dérivés (id, complexityScore, calledInternals, signature) via AST.
  3. Générer les embeddings locaux.
  4. Upsert dans LanceDB.
- Pour les fichiers **cachés** (hash inchangé) : les cards existantes dans LanceDB restent en place.
- Option `--rebuild-rag` : force la réindexation de tous les fichiers (supprime et reconstruit la table).
- Stockage du cache : `.anatoly/rag/cache.json` (hash → lastIndexed)

---

## 8. Intégration dans le pipeline

```ts
const pipeline = [
  'scan',
  'estimate',
  'review',     // ← produit aussi les FunctionCards (si --enable-rag)
  'index',      // ← NOUVELLE PHASE : embeddings + upsert LanceDB (si --enable-rag)
  'report'
];
```

- Dans `review` : l'agent produit les FunctionCards en plus de la review standard.
- Dans `index` : embeddings locaux + upsert dans LanceDB.
- Le `ragClient` (accès au vector store) est passé au step `review` pour que le tool `findSimilarFunctions` soit disponible.

**Note :** Au premier run avec RAG, le tool `findSimilarFunctions` n'aura pas de données. Le prompt doit le mentionner. Dès le second run (ou après la phase `index` du premier run), les données sont disponibles.

---

## 9. Tool pour l'agent Claude

**Fichier :** `src/rag/tools.ts`

```ts
export const findSimilarFunctionsTool = {
  name: 'findSimilarFunctions',
  description: 'Rechercher les fonctions sémantiquement similaires dans tout le codebase indexé',
  input_schema: {
    type: 'object',
    properties: {
      functionId: { type: 'string', description: 'ID de la fonction à comparer' },
      maxResults: { type: 'number', default: 8 },
      minScore: { type: 'number', default: 0.78 }
    },
    required: ['functionId']
  }
};
```

### Intégration dans le prompt de review

Quand le RAG est activé et que l'index contient des données :
- **Remplacer** l'instruction de détection manuelle de duplication (grep-based) par : « Utilise le tool `findSimilarFunctions` pour chaque fonction avant de conclure sur l'axe duplication. »
- L'agent reçoit en retour : tableau avec `name`, `filePath`, `score`, `summary`.
- Cela évite les contradictions entre détection grep et détection sémantique.

---

## 10. Mise à jour des rapports

**Dans chaque .rev.md :** nouvelle section après le verdict (si RAG activé)

```markdown
### Similarités sémantiques détectées
| Fonction | Fichier | Score | Suggestion |
|----------|---------|-------|------------|
...
```

**Dans report.md global :**
- Section « Duplications sémantiques » (top clusters par score)
- Nouveau métrique : `semanticCoherenceScore`

Mise à jour du schéma Zod `ReviewFileSchema` pour inclure les résultats RAG optionnels.

---

## 11. CLI — Nouveaux flags

Dans `commands/run.ts` :

```ts
.option('--enable-rag', 'Active le RAG sémantique cross-file', false)
.option('--rebuild-rag', 'Force la réindexation complète', false)
```

Dans `status` : ajouter `--show-rag` pour afficher stats d'index (nombre de cartes, dernière mise à jour, etc.).

Dans `.anatoly.yml` :

```yaml
rag:
  enabled: false          # ou true pour activer par défaut
```

---

## 12. Checklist d'implémentation

### Phase 1 — Core RAG
- [ ] Créer `src/rag/` + tous les fichiers ci-dessus
- [ ] Implémenter FunctionCardSchema + types
- [ ] Implémenter `createEmbedder()` + `embed()` (Xenova/all-MiniLM-L6-v2)
- [ ] Implémenter LanceDB wrapper (init, upsert, search, deleteByFile)
- [ ] Implémenter indexer incrémental
- [ ] Créer `scripts/download-model.js` + postinstall hook

### Phase 2 — Extraction AST
- [ ] Extraire `calledInternals` via tree-sitter (call_expression dans le corps)
- [ ] Calculer `complexityScore` via heuristique cyclomatique (branches AST)
- [ ] Extraire `signature` depuis l'AST

### Phase 3 — Intégration review
- [ ] Modifier le prompt système pour produire les FunctionCards pendant la review
- [ ] Étendre `ReviewFileSchema` avec champ `functionCards` optionnel
- [ ] Modifier `reviewer.ts` pour extraire et valider les cards
- [ ] Ajouter le tool `findSimilarFunctions` au Claude Agent SDK
- [ ] Remplacer la détection de duplication grep par RAG quand activé

### Phase 4 — Pipeline + CLI
- [ ] Ajouter phase `index` dans le pipeline (après review)
- [ ] Ajouter flags CLI (`--enable-rag`, `--rebuild-rag`)
- [ ] Ajouter config `rag.enabled` dans `.anatoly.yml`
- [ ] Ajouter `--show-rag` à la commande `status`

### Phase 5 — Rapports
- [ ] Mettre à jour templates `.rev.md` (section similarités)
- [ ] Ajouter section « Duplications sémantiques » dans `report.md`
- [ ] Ajouter métrique `semanticCoherenceScore`

### Phase 6 — Tests & Robustesse
- [ ] Tests unitaires (embeddings, upsert, search, AST extraction)
- [ ] Test end-to-end sur petit repo + monorepo
- [ ] Vérifier résilience (crash pendant index → reprise)
- [ ] Atomicité des écritures (`.anatoly/rag/lock`)

### Phase 7 — Documentation
- [ ] Mise à jour README (section RAG + exemple de sortie)
- [ ] Mise à jour du CHANGELOG.md

---

## 13. Dépendances à ajouter (package.json)

```json
{
  "dependencies": {
    "@xenova/transformers": "^2.17.0",
    "lancedb": "^0.15.0"
  }
}
```
